#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#ifdef _WIN32
    #include <windows.h>
#endif

/* --- KOLORY --- */
#define KOLOR_RESET   "\033[0m"
#define KOLOR_CYAN    "\033[1;36m"
#define KOLOR_YELLOW  "\033[1;33m"
#define KOLOR_GREEN   "\033[1;32m"
#define KOLOR_MAGENTA "\033[1;35m"
#define KOLOR_RED     "\033[1;31m"
#define KOLOR_BOLD    "\033[1m"
#define KOLOR_WHITE   "\033[1;37m"
#define KOLOR_SZARY    "\033[1;30m"
#define KOLOR_NIEBIESKI "\033[1;34m"
#define KOLOR_ROZOWY   "\033[1;95m"
#define KOLOR_JASNOZIELONY "\033[1;92m"

/* --- STALE WYMIARY OKNA --- */
#define OKNO_WYSOKOSC 40
#define OKNO_SZEROKOSC 120

/* --- RPG --- */
#define PLECAK_MAX_POJEMNOSC 30
#define MAX_WYSOKOSC 15
#define MAX_SZEROKOSC 30

#define SLOT_BRON 0
#define SLOT_TARCZA 1
#define SLOT_ZBROJA 2
#define SLOT_ILOSC 3

#define LEVELUP_XP 100

#define SZANSA_KUPCA_W_WIOSCE 60

#define LIMIT_LECZENIA 10

/* --- TYPY LOKACJI --- */
typedef enum {
    LOKACJA_LAS,
    LOKACJA_WIOSKA,
    LOKACJA_JASKINIA,
    LOKACJA_OBOZ,
    LOKACJA_POLANA,
    LOKACJA_RUINY
} TypLokacji;

const char* nazwy_lokacji[] = {
    "Las",
    "Wioska",
    "Jaskinia",
    "Oboz wrogow",
    "Polana",
    "Ruiny"
};

/* --- MAPA --- */
typedef enum {
    PUSTE, SCIANA, SKARB, PULAPKA, PRZECIWNIK, BRAMA, SKARB_SPEC
} TypKomorki;

typedef struct {
    TypKomorki typ;
} KomorkaMapy;

typedef struct {
    int szerokosc;
    int wysokosc;
    KomorkaMapy komorki[MAX_WYSOKOSC][MAX_SZEROKOSC];
    int czy_jest_kupiec;
} Mapa;

/* --- PRZEDMIOTY --- */
typedef enum {
    PRZEDMIOT_BRON,
    PRZEDMIOT_TARCZA,
    PRZEDMIOT_ZBROJA,
    PRZEDMIOT_LECZENIE,
    PRZEDMIOT_INNY
} TypPrzedmiotu;

typedef enum {
    RZAD_ZNISZCZONY,
    RZAD_ZWYKLY,
    RZAD_SLABY,
    RZAD_DOBRY,
    RZAD_MISTRZ,
    RZAD_LEG
} RzadkoscPrzedmiotu;

const char* nazwy_rzadkosci[] = {
    "Zniszczony",
    "Zwykly",
    "Slabej jakosci",
    "Dobrej jakosci",
    "Mistrzowski",
    "LEGENDARNY"
};

typedef enum {
    LECZENIE_ZWYKLE,
    LECZENIE_HEALER,
    LECZENIE_MAG
} TypLeczenia;

typedef enum {
    AMULET_SZCZESCIA,
    AMULET_REGENERACJI,
    AMULET_MISTRZA,
    AMULET_LEGENDARNY
} TypAmuletu;

typedef struct {
    char nazwa[50];
    TypPrzedmiotu typ;
    RzadkoscPrzedmiotu rzadkosc;
    int bonus_obrazen;
    int bonus_odpornosci;
    int bonus_HP;
    int bonus_sila;
    float bonus_szybkosc;
    int waga;
    int cena;
    int leczenie;
    TypLeczenia typ_leczenia;
    TypAmuletu typ_amuletu;
} Przedmiot;

/* --- PLECAK --- */
typedef struct {
    Przedmiot *items;
    int count;
    int capacity;
    int zajete_miejsce;
    int max_miejsce;
} Plecak;

/* --- POSTAC --- */
typedef struct {
    int HP;
    int max_HP;
    int AG;
    float odp_pancerza;
    float sila;
    double mnoznik_hp;
    int waga;
    float zasieg_walki;
    float zasieg_wizji;
    long int XP;
    float szybkosc;
    int pozycjaX;
    int pozycjaY;
    Przedmiot* sloty[SLOT_ILOSC];
    int bonus_HP;
    int bonus_sila;
    int bonus_odpornosc;
    float bonus_szybkosc;
    int waluta;
    int poziom;
    int xp_do_lvlu;
    int szczescie;
    int liczba_leczen; // Liczba mikstur leczenia
    int liczba_pulapek; // Liczba pułapek, w które gracz wszedł
    int liczba_wrogow;  // Liczba wrogów, z którymi gracz walczył
} Postac;

const char* kolory_rzadkosci[] = {
    KOLOR_SZARY,         // Zniszczony
    KOLOR_WHITE,         // Zwykly
    KOLOR_NIEBIESKI,     // Slabej jakosci
    KOLOR_JASNOZIELONY,  // Dobrej jakosci
    KOLOR_ROZOWY,        // Mistrzowski
    KOLOR_BOLD KOLOR_YELLOW // LEGENDARNY
};

/* --- BFS --- */
typedef struct {
    int x;
    int y;
} Pozycja;

/* --- CZYSZCZENIE EKRANU --- */
void czysc_ekran() {
#ifdef _WIN32
    system("cls");
#else
    printf("\033[2J\033[H");
#endif
}

/* --- PLECAK --- */
void init_plecak(Plecak *plecak, int max_miejsce) {
    plecak->capacity = 8;
    plecak->items = malloc(plecak->capacity * sizeof(Przedmiot));
    plecak->count = 0;
    plecak->zajete_miejsce = 0;
    plecak->max_miejsce = max_miejsce;
}

void powieksz_plecak(Plecak *plecak) {
    plecak->capacity *= 2;
    plecak->items = realloc(plecak->items, plecak->capacity * sizeof(Przedmiot));
}

int gracz_ma_legendarny_amulet(Plecak *plecak) {
    for (int i = 0; i < plecak->count; i++) {
        Przedmiot *item = &plecak->items[i];
        if (item->typ == PRZEDMIOT_INNY && item->rzadkosc == RZAD_LEG && strstr(item->nazwa, "Amulet Regeneracji")) {
            return 1;
        }
    }
    return 0;
}

int dodaj_do_plecaka(Plecak *plecak, Przedmiot item, Postac* gracz) {
    // Limit mikstur leczenia
    if (item.typ == PRZEDMIOT_LECZENIE) {
        int licznik = 0;
        for (int i = 0; i < plecak->count; i++)
            if (plecak->items[i].typ == PRZEDMIOT_LECZENIE) licznik++;
        if (licznik >= LIMIT_LECZENIA) {
            printf(KOLOR_RED "Masz juz maksymalna liczbe mikstur leczenia (%d)!\n" KOLOR_RESET, LIMIT_LECZENIA);
            return 0;
        }
    }
    if (plecak->zajete_miejsce + item.waga > plecak->max_miejsce) {
        printf(KOLOR_RED "Plecak nie ma miejsca! (waga: %d/%d)\n" KOLOR_RESET, plecak->zajete_miejsce, plecak->max_miejsce);
        return 0;
    }
    if (plecak->count >= plecak->capacity) powieksz_plecak(plecak);

    // Leczenie na górze plecaka
    if (item.typ == PRZEDMIOT_LECZENIE) {
        for (int i = plecak->count; i > 0; i--) {
            plecak->items[i] = plecak->items[i-1];
        }
        plecak->items[0] = item;
    } else {
        plecak->items[plecak->count] = item;
    }
    plecak->count++;
    plecak->zajete_miejsce += item.waga;
    if (item.rzadkosc == RZAD_LEG)
        printf(KOLOR_BOLD KOLOR_YELLOW "LEGENDARNY przedmiot '%s' dodany do plecaka! (waga: %d/%d)\n" KOLOR_RESET, item.nazwa, plecak->zajete_miejsce, plecak->max_miejsce);
    else if (item.typ == PRZEDMIOT_LECZENIE)
        printf(KOLOR_GREEN "Przedmiot leczący '%s' dodany do plecaka! (waga: %d/%d)\n" KOLOR_RESET, item.nazwa, plecak->zajete_miejsce, plecak->max_miejsce);
    else
        printf("Przedmiot '%s' dodany do plecaka (waga: %d/%d).\n", item.nazwa, plecak->zajete_miejsce, plecak->max_miejsce);
    return 1;
}

void usun_z_plecaka(Plecak *plecak, int idx) {
    if (idx < 0 || idx >= plecak->count) return;
    plecak->zajete_miejsce -= plecak->items[idx].waga;
    for (int i = idx; i < plecak->count - 1; i++)
        plecak->items[i] = plecak->items[i + 1];
    plecak->count--;
}

/* --- GENEROWANIE PRZEDMIOTÓW --- */
Przedmiot generuj_przedmiot(Postac* gracz) {
    Przedmiot item;
    int roll_typ = rand() % 100;
    int typ;
    if (roll_typ < 15) typ = 3; // 15% szans na leczenie
    else typ = rand() % 4; // 85% szans na broń/tarcze/zbroje
    int szczescie = gracz ? gracz->szczescie : 0;
    int poziom = gracz ? gracz->poziom : 1;

    // Szansa na rzadkosc (im wyzszy poziom i szczescie, tym lepsze)
    int roll = rand() % 100 + szczescie + poziom * 2;
    if (roll > 98) item.rzadkosc = RZAD_LEG;
    else if (roll > 92) item.rzadkosc = RZAD_MISTRZ;
    else if (roll > 80) item.rzadkosc = RZAD_DOBRY;
    else if (roll > 60) item.rzadkosc = RZAD_SLABY;
    else if (roll > 30) item.rzadkosc = RZAD_ZWYKLY;
    else item.rzadkosc = RZAD_ZNISZCZONY;

    // --- MNOŻNIKI RZADKOŚCI ---
    float mnoznik = 1.0f;
    switch (item.rzadkosc) {
        case RZAD_ZNISZCZONY: mnoznik = 0.5f; break; // -50%
        case RZAD_ZWYKLY:     mnoznik = 1.0f; break; // 100%
        case RZAD_SLABY:      mnoznik = 0.8f; break; // 80%
        case RZAD_DOBRY:      mnoznik = 1.2f + szczescie * 0.01f; break; // 120% + szczęście
        case RZAD_MISTRZ:     mnoznik = 1.5f + szczescie * 0.01f; break; // 150% + szczęście
        case RZAD_LEG:        mnoznik = 2.5f + szczescie * 0.02f; break; // 250% + szczęście
        default:              mnoznik = 1.0f;
    }

    item.leczenie = 0;
    item.typ_leczenia = LECZENIE_ZWYKLE;
    item.typ_amuletu = AMULET_SZCZESCIA;

    // --- Bron, Tarcza, Zbroja, Leczenie, Amulet ---
    if (typ == 0) { // Bron
        item.typ = PRZEDMIOT_BRON;
        if (item.rzadkosc == RZAD_LEG) snprintf(item.nazwa, 50, "LEGENDARNY Miecz");
        else if (item.rzadkosc == RZAD_MISTRZ) snprintf(item.nazwa, 50, "Miecz Mistrza");
        else if (item.rzadkosc == RZAD_DOBRY) snprintf(item.nazwa, 50, "Dobry Miecz");
        else if (item.rzadkosc == RZAD_SLABY) snprintf(item.nazwa, 50, "Slaby Miecz");
        else if (item.rzadkosc == RZAD_ZWYKLY) snprintf(item.nazwa, 50, "Miecz");
        else snprintf(item.nazwa, 50, "Zniszczony Miecz");
        item.bonus_obrazen = (int)((2 + poziom + item.rzadkosc * 4 + rand() % (2 + item.rzadkosc * 2)) * mnoznik);
        item.bonus_odpornosci = 0;
        item.bonus_HP = (int)((item.rzadkosc * 2 + rand() % (2 + item.rzadkosc)) * mnoznik);
        item.bonus_sila = (int)((item.rzadkosc + rand() % (1 + item.rzadkosc)) * mnoznik);
        item.bonus_szybkosc = 0.1f * item.rzadkosc * mnoznik;
        item.waga = 3 + item.rzadkosc;
        item.cena = (int)((10 + item.rzadkosc * 30 + poziom * 2) * mnoznik);
    } else if (typ == 1) { // Tarcza
        item.typ = PRZEDMIOT_TARCZA;
        if (item.rzadkosc == RZAD_LEG) snprintf(item.nazwa, 50, "LEGENDARNA Tarcza");
        else if (item.rzadkosc == RZAD_MISTRZ) snprintf(item.nazwa, 50, "Tarcza Mistrza");
        else if (item.rzadkosc == RZAD_DOBRY) snprintf(item.nazwa, 50, "Dobra Tarcza");
        else if (item.rzadkosc == RZAD_SLABY) snprintf(item.nazwa, 50, "Slaba Tarcza");
        else if (item.rzadkosc == RZAD_ZWYKLY) snprintf(item.nazwa, 50, "Tarcza");
        else snprintf(item.nazwa, 50, "Zniszczona Tarcza");
        item.bonus_odpornosci = (int)((2 + poziom + item.rzadkosc * 4 + rand() % (2 + item.rzadkosc * 2)) * mnoznik);
        item.bonus_obrazen = 0;
        item.bonus_HP = (int)((item.rzadkosc * 3 + rand() % (2 + item.rzadkosc)) * mnoznik);
        item.bonus_sila = 0;
        item.bonus_szybkosc = -0.05f * item.rzadkosc * mnoznik;
        item.waga = 4 + item.rzadkosc;
        item.cena = (int)((12 + item.rzadkosc * 30 + poziom * 2) * mnoznik);
    } else if (typ == 2) { // Zbroja
        item.typ = PRZEDMIOT_ZBROJA;
        if (item.rzadkosc == RZAD_LEG) snprintf(item.nazwa, 50, "LEGENDARNA Zbroja");
        else if (item.rzadkosc == RZAD_MISTRZ) snprintf(item.nazwa, 50, "Zbroja Mistrza");
        else if (item.rzadkosc == RZAD_DOBRY) snprintf(item.nazwa, 50, "Dobra Zbroja");
        else if (item.rzadkosc == RZAD_SLABY) snprintf(item.nazwa, 50, "Slaba Zbroja");
        else if (item.rzadkosc == RZAD_ZWYKLY) snprintf(item.nazwa, 50, "Zbroja");
        else snprintf(item.nazwa, 50, "Zniszczona Zbroja");
        item.bonus_odpornosci = (int)((3 + poziom + item.rzadkosc * 5 + rand() % (3 + item.rzadkosc * 2)) * mnoznik);
        item.bonus_obrazen = 0;
        item.bonus_HP = (int)((5 + item.rzadkosc * 5 + rand() % (3 + item.rzadkosc * 2)) * mnoznik);
        item.bonus_sila = 0;
        item.bonus_szybkosc = -0.1f * item.rzadkosc * mnoznik;
        item.waga = 5 + item.rzadkosc;
        item.cena = (int)((15 + item.rzadkosc * 40 + poziom * 2) * mnoznik);
    } else if (typ == 3) { // Leczenie
        item.typ = PRZEDMIOT_LECZENIE;
        int rodzaj = rand() % 3;
        if (rodzaj == 0) {
            item.typ_leczenia = LECZENIE_ZWYKLE;
            snprintf(item.nazwa, 50, "Zwykla Mikstura Leczenia");
            item.leczenie = (int)((25 + poziom * 2 + item.rzadkosc * 5) * mnoznik);
        } else if (rodzaj == 1) {
            item.typ_leczenia = LECZENIE_HEALER;
            snprintf(item.nazwa, 50, "Mikstura Leczenia Healer'a");
            item.leczenie = (int)((40 + poziom * 3 + item.rzadkosc * 8) * mnoznik);
        } else {
            item.typ_leczenia = LECZENIE_MAG;
            snprintf(item.nazwa, 50, "Mikstura Leczenia Maga");
            item.leczenie = (int)((60 + poziom * 4 + item.rzadkosc * 12) * mnoznik);
        }
        item.bonus_obrazen = 0;
        item.bonus_odpornosci = 0;
        item.bonus_HP = 0;
        item.bonus_sila = 0;
        item.bonus_szybkosc = 0.0f;
        item.waga = 1;
        item.cena = (int)((10 + item.rzadkosc * 10 + poziom * 2) * mnoznik);
    } else { // Amulety
        item.typ = PRZEDMIOT_INNY;
        int rodzaj = rand() % 4;
        if (rodzaj == 0) {
            item.typ_amuletu = AMULET_SZCZESCIA;
            snprintf(item.nazwa, 50, "Amulet Szczescia");
            item.bonus_HP = (int)((2 + item.rzadkosc) * mnoznik);
        } else if (rodzaj == 1) {
            item.typ_amuletu = AMULET_REGENERACJI;
            snprintf(item.nazwa, 50, "Amulet Regeneracji");
            item.bonus_HP = (int)((5 + item.rzadkosc * 2) * mnoznik);
        } else if (rodzaj == 2) {
            item.typ_amuletu = AMULET_MISTRZA;
            snprintf(item.nazwa, 50, "Amulet Mistrza");
            item.bonus_HP = (int)((10 + item.rzadkosc * 3) * mnoznik);
        } else {
            item.typ_amuletu = AMULET_LEGENDARNY;
            snprintf(item.nazwa, 50, "LEGENDARNY Amulet");
            item.bonus_HP = (int)((20 + item.rzadkosc * 5) * mnoznik);
        }
        item.bonus_obrazen = 0;
        item.bonus_odpornosci = 0;
        item.bonus_sila = 0;
        item.bonus_szybkosc = 0.0f;
        item.waga = 0;
        item.cena = (int)((50 + item.rzadkosc * 40 + poziom * 2) * mnoznik);
        item.leczenie = 0;
    }
    return item;
}

/* --- BONUSY --- */
void zastosuj_bonusy(Postac* postac, Przedmiot *item) {
    postac->bonus_HP += item->bonus_HP;
    postac->bonus_sila += item->bonus_sila;
    postac->bonus_odpornosc += item->bonus_odpornosci;
    postac->bonus_szybkosc += item->bonus_szybkosc;
}

void usun_bonusy(Postac* postac, Przedmiot *item) {
    postac->bonus_HP -= item->bonus_HP;
    postac->bonus_sila -= item->bonus_sila;
    postac->bonus_odpornosc -= item->bonus_odpornosci;
    postac->bonus_szybkosc -= item->bonus_szybkosc;
}

/* --- SLOTY POSTACI --- */
void pokaz_zmiany_statystyk(Postac *gracz, Przedmiot *item) {
    printf("\nZmiany statystyk po zalozeniu przedmiotu:\n");
    int hp0 = gracz->HP + gracz->bonus_HP;
    int hp1 = hp0 + item->bonus_HP;
    int sila0 = gracz->sila + gracz->bonus_sila;
    int sila1 = sila0 + item->bonus_sila;
    int odp0 = gracz->odp_pancerza + gracz->bonus_odpornosc;
    int odp1 = odp0 + item->bonus_odpornosci;
    float szybkosc0 = gracz->szybkosc + gracz->bonus_szybkosc;
    float szybkosc1 = szybkosc0 + item->bonus_szybkosc;

    int bron0 = 0, bron1 = 0;
    if (item->typ == PRZEDMIOT_BRON) {
        if (gracz->sloty[SLOT_BRON]) bron0 = gracz->sloty[SLOT_BRON]->bonus_obrazen;
        bron1 = item->bonus_obrazen;
        printf("Obrazenia: %d -> %d\n", sila0 + bron0, sila1 + bron1);
    }

    printf("HP: %d -> %d\n", hp0, hp1);
    printf("Sila: %d -> %d\n", sila0, sila1);
    printf("Odpornosc: %d -> %d\n", odp0, odp1);
    printf("Szybkosc: %.2f -> %.2f\n", szybkosc0, szybkosc1);
}

void wyposaz_przedmiot(Postac *gracz, Plecak *plecak, int indeks) {
    if (indeks < 0 || indeks >= plecak->count) {
        printf("Nieprawidlowy indeks.\n");
        return;
    }
    Przedmiot *item = &plecak->items[indeks];
    int slot = -1;
    if (item->typ == PRZEDMIOT_BRON) slot = SLOT_BRON;
    else if (item->typ == PRZEDMIOT_TARCZA) slot = SLOT_TARCZA;
    else if (item->typ == PRZEDMIOT_ZBROJA) slot = SLOT_ZBROJA;

    if (slot == -1) {
        printf(KOLOR_RED "Ten przedmiot nie moze byc wyposazony.\n" KOLOR_RESET);
        printf("Wcisnij ENTER aby kontynuowac...");
        char linia[16];
        fgets(linia, sizeof(linia), stdin);
        return;
    }
    printf("\n--- SLOT: %s ---\n", slot == SLOT_BRON ? "Bron" : slot == SLOT_TARCZA ? "Tarcza" : "Zbroja");
    pokaz_zmiany_statystyk(gracz, item);
    printf("Chcesz wyposazyc '%s'? (T/N): ", item->nazwa);
    char odp;
    scanf(" %c", &odp);
    int c; while ((c = getchar()) != '\n' && c != EOF) {}
    if (odp == 'T' || odp == 't') {
        // Jeśli slot jest zajęty, zdejmij bonusy i przenieś stary przedmiot do plecaka
        if (gracz->sloty[slot] != NULL) {
            usun_bonusy(gracz, gracz->sloty[slot]); // ODEJMIJ bonusy starego przedmiotu!
            if (plecak->count >= plecak->capacity) powieksz_plecak(plecak);
            plecak->items[plecak->count++] = *(gracz->sloty[slot]);
            plecak->zajete_miejsce += gracz->sloty[slot]->waga;
            printf(KOLOR_YELLOW "Zdejmujesz '%s' i chowasz do plecaka.\n" KOLOR_RESET, gracz->sloty[slot]->nazwa);
            free(gracz->sloty[slot]);
            gracz->sloty[slot] = NULL;
        }
        // Załóż nowy przedmiot i dodaj bonusy
        gracz->sloty[slot] = malloc(sizeof(Przedmiot));
        *(gracz->sloty[slot]) = *item;
        zastosuj_bonusy(gracz, item); // DODAJ bonusy nowego przedmiotu!
        printf("Wyposazono: %s\n", item->nazwa);
        usun_z_plecaka(plecak, indeks);
    } else {
        printf("Przedmiot pozostaje w plecaku.\n");
    }
}

void uzyj_leczenie(Postac *gracz, Plecak *plecak, int idx) {
    if (idx < 0 || idx >= plecak->count) return;
    Przedmiot *item = &plecak->items[idx];
    if (item->typ != PRZEDMIOT_LECZENIE) {
        printf("To nie jest przedmiot leczący!\n");
        return;
    }
    int max_hp = gracz->max_HP + gracz->bonus_HP;
    int przed = gracz->HP;
    int ile_brakuje = max_hp - gracz->HP;
    if (ile_brakuje <= 0) {
        printf("Masz już pełne zdrowie!\n");
        return;
    }
    if (item->leczenie > ile_brakuje) {
        printf(KOLOR_YELLOW "Eliksir leczy %d HP, ale brakuje Ci tylko %d HP.\n" KOLOR_RESET, item->leczenie, ile_brakuje);
        printf("Czy na pewno chcesz go użyć? (T/N): ");
        char odp[8];
        fgets(odp, sizeof(odp), stdin);
        if (odp[0] != 'T' && odp[0] != 't') {
            printf("Anulowano użycie eliksiru.\n");
            return;
        }
    }
    gracz->HP += item->leczenie;
    if (gracz->HP > max_hp)
        gracz->HP = max_hp;
    printf(KOLOR_GREEN "Uzywasz %s i leczysz sie o %d HP! (HP: %d -> %d)\n" KOLOR_RESET, item->nazwa, item->leczenie, przed, gracz->HP);
    usun_z_plecaka(plecak, idx);
}

/* --- PLECAK I SLOTY - INTERFEJS --- */
void przegladaj_plecak(Plecak *plecak, Postac *gracz) {
    while (1) {
        czysc_ekran();
        printf(KOLOR_BOLD KOLOR_CYAN "\n=== SLOTY POSTACI ===\n" KOLOR_RESET);
        for (int i = 0; i < SLOT_ILOSC; i++) {
            if (gracz->sloty[i]) {
                printf("%s: ", i == SLOT_BRON ? "Bron" : i == SLOT_TARCZA ? "Tarcza" : "Zbroja");
                if (gracz->sloty[i]->rzadkosc == RZAD_LEG)
                    printf(KOLOR_BOLD KOLOR_YELLOW "%s" KOLOR_RESET "\n", gracz->sloty[i]->nazwa);
                else
                    printf("%s\n", gracz->sloty[i]->nazwa);
            } else {
                printf("%s: brak\n", i == SLOT_BRON ? "Bron" : i == SLOT_TARCZA ? "Tarcza" : "Zbroja");
            }
        }
        printf(KOLOR_BOLD KOLOR_CYAN "\n=== PLECAK (waga: %d/%d) ===\n" KOLOR_RESET, plecak->zajete_miejsce, plecak->max_miejsce);
        if (plecak->count == 0) {
            printf("Plecak jest pusty.\n");
        } else {
            for (int i = 0; i < plecak->count; i++) {
                Przedmiot *item = &plecak->items[i];
                printf("%s", kolory_rzadkosci[item->rzadkosc]);
                printf("%d: %s (%s", i, item->nazwa,
                    item->rzadkosc == RZAD_LEG ? "LEGENDARNY, " : "");
                switch (item->typ) {
                    case PRZEDMIOT_BRON: printf("Bron"); break;
                    case PRZEDMIOT_TARCZA: printf("Tarcza"); break;
                    case PRZEDMIOT_ZBROJA: printf("Zbroja"); break;
                    case PRZEDMIOT_LECZENIE: printf("Leczenie"); break;
                    case PRZEDMIOT_INNY: printf("Amulet"); break;
                    default: printf("Inny");
                }
                printf(", waga: %d, cena: %d", item->waga, item->cena);
                if (item->bonus_obrazen) printf(", obrazenia: %d", item->bonus_obrazen);
                if (item->bonus_odpornosci) printf(", odpornosc: %d", item->bonus_odpornosci);
                if (item->bonus_HP) printf(", HP: %d", item->bonus_HP);
                if (item->bonus_sila) printf(", sila: %d", item->bonus_sila);
                if (item->bonus_szybkosc) printf(", szybkosc: %.2f", item->bonus_szybkosc);
                if (item->typ == PRZEDMIOT_LECZENIE) printf(", leczenie: %d", item->leczenie);
                if (item->typ == PRZEDMIOT_INNY) {
                    if (item->rzadkosc == RZAD_LEG)
                        printf(KOLOR_MAGENTA " | Amulet Regeneracji: +10 HP, po walce leczy 10HP, po pulapce 5HP" KOLOR_RESET);
                    else
                        printf(KOLOR_MAGENTA " | Amulet: +5 HP, nie zajmuje miejsca w plecaku" KOLOR_RESET);
                }
                printf(")" KOLOR_RESET "\n");
            }
        }
        printf("\nWybierz nr przedmiotu do wyposazenia/uzycia (q aby wyjsc, L <nr> aby uzyc leczenie, W <nr> aby wyrzucic, Z <slot> aby zdjac przedmiot ze slotu): "); //aby zjadc przedmiot to np Z 0 (od 0 do 2)
        char linia[32];
        fgets(linia, sizeof(linia), stdin);
        int wybor;
        if (linia[0] == 'q' || linia[0] == 'Q') break;
        if (sscanf(linia, "L %d", &wybor) == 1) {
            uzyj_leczenie(gracz, plecak, wybor);
        } else if (sscanf(linia, "W %d", &wybor) == 1) {
            if (wybor >= 0 && wybor < plecak->count) {
                printf("Wyrzucono %s z plecaka.\n", plecak->items[wybor].nazwa);
                usun_z_plecaka(plecak, wybor);
                printf("Wcisnij ENTER aby kontynuowac...");
                fgets(linia, sizeof(linia), stdin);
            }
        } else if (sscanf(linia, "Z %d", &wybor) == 1) {
            // Zdejmowanie przedmiotu ze slotu (0-Bron, 1-Tarcza, 2-Zbroja)
            if (wybor >= 0 && wybor < SLOT_ILOSC && gracz->sloty[wybor]) {
                if (plecak->zajete_miejsce + gracz->sloty[wybor]->waga > plecak->max_miejsce) {
                    printf(KOLOR_RED "Brak miejsca w plecaku na zdjęcie przedmiotu!\n" KOLOR_RESET);
                } else {
                    usun_bonusy(gracz, gracz->sloty[wybor]);
                    if (plecak->count >= plecak->capacity) powieksz_plecak(plecak);
                    plecak->items[plecak->count++] = *(gracz->sloty[wybor]);
                    plecak->zajete_miejsce += gracz->sloty[wybor]->waga;
                    printf(KOLOR_YELLOW "Zdejmujesz '%s' i chowasz do plecaka.\n" KOLOR_RESET, gracz->sloty[wybor]->nazwa);
                    free(gracz->sloty[wybor]);
                    gracz->sloty[wybor] = NULL;
                }
                printf("Wcisnij ENTER aby kontynuowac...");
                fgets(linia, sizeof(linia), stdin);
            }
        } else if (sscanf(linia, "%d", &wybor) == 1) {
            if (wybor >= 0 && wybor < plecak->count) {
                if (plecak->items[wybor].typ == PRZEDMIOT_LECZENIE)
                    uzyj_leczenie(gracz, plecak, wybor);
                else
                    wyposaz_przedmiot(gracz, plecak, wybor);
            }
        }
    }
}

/* --- GENEROWANIE MAPY --- */
void generuj_mape(Mapa* mapa, TypLokacji typ_lokacji) {
    switch (typ_lokacji) {
        case LOKACJA_LAS:
            mapa->szerokosc = 20;
            mapa->wysokosc = 10;
            break;
        case LOKACJA_WIOSKA:
            mapa->szerokosc = 15;
            mapa->wysokosc = 8;
            mapa->czy_jest_kupiec = 1; // ZAWSZE jest kupiec w wiosce
            break;
        case LOKACJA_JASKINIA:
            mapa->szerokosc = 12;
            mapa->wysokosc = 7;
            break;
        case LOKACJA_OBOZ:
            mapa->szerokosc = 10;
            mapa->wysokosc = 6;
            break;
        case LOKACJA_POLANA:
            mapa->szerokosc = 18;
            mapa->wysokosc = 8;
            break;
        case LOKACJA_RUINY:
            mapa->szerokosc = 13;
            mapa->wysokosc = 7;
            break;
        default:
            mapa->szerokosc = 12;
            mapa->wysokosc = 8;
    }
    if (typ_lokacji == LOKACJA_WIOSKA)
        mapa->czy_jest_kupiec = (rand() % 100 < 85) ? 1 : 0; // 85% szans na kupca
    else
        mapa->czy_jest_kupiec = 0;

    for (int y = 0; y < mapa->wysokosc; y++) {
        for (int x = 0; x < mapa->szerokosc; x++) {
            int wartosc_losowa = rand() % 100;
            if (wartosc_losowa < 35)
                mapa->komorki[y][x].typ = SCIANA;
            else if (wartosc_losowa < 40)
                mapa->komorki[y][x].typ = PULAPKA;
            else if (wartosc_losowa < 50)
                mapa->komorki[y][x].typ = PRZECIWNIK;
            else
                mapa->komorki[y][x].typ = PUSTE;
        }
    }
    int liczba_skarbow = 1;
    int dodaj_specjalny = 0;
    if (typ_lokacji == LOKACJA_WIOSKA || typ_lokacji == LOKACJA_OBOZ) {
        liczba_skarbow = 2;
        dodaj_specjalny = 1;
    }
    for (int i = 0; i < liczba_skarbow; i++) {
        int skarbX, skarbY;
        do {
            skarbX = rand() % mapa->szerokosc;
            skarbY = rand() % mapa->wysokosc;
        } while (mapa->komorki[skarbY][skarbX].typ != PUSTE);
        if (dodaj_specjalny && i == liczba_skarbow - 1)
            mapa->komorki[skarbY][skarbX].typ = SKARB_SPEC;
        else
            mapa->komorki[skarbY][skarbX].typ = SKARB;
    }
    int bramaX, bramaY;
    do {
        bramaX = rand() % mapa->szerokosc;
        bramaY = rand() % mapa->wysokosc;
    } while (mapa->komorki[bramaY][bramaX].typ != PUSTE);
    mapa->komorki[bramaY][bramaX].typ = BRAMA;
}

/* --- MAPA I RYSOWANIE --- */
void rysuj_legenda(Mapa* mapa, TypLokacji typ_lokacji) {
    printf(KOLOR_BOLD KOLOR_MAGENTA "LEGENDA MAPY:\n" KOLOR_RESET);
    printf(". - puste pole\n");
    printf(KOLOR_WHITE "#" KOLOR_RESET " - sciana\n");
    printf(KOLOR_YELLOW "S" KOLOR_RESET " - skarb (zdobywasz 50 XP)\n");
    printf(KOLOR_YELLOW "$" KOLOR_RESET " - specjalny skarb (moze byc pusty, ale daje lepsze przedmioty)\n");
    printf(KOLOR_RED "T" KOLOR_RESET " - pulapka (tracisz 10 HP i zyskujesz 1 szczescia)\n");
    printf(KOLOR_RED "P" KOLOR_RESET " - przeciwnik (walka)\n");
    printf(KOLOR_CYAN "B" KOLOR_RESET " - brama (przejscie na kolejny poziom – mapa generowana na nowo)\n");
    printf(KOLOR_GREEN "@" KOLOR_RESET " - Twoja postac\n");
    if (typ_lokacji == LOKACJA_WIOSKA) {
        if (mapa->czy_jest_kupiec)
            printf(KOLOR_BOLD KOLOR_YELLOW "W tej wiosce jest kupiec! (K)\n" KOLOR_RESET);
        else
            printf(KOLOR_BOLD KOLOR_RED "W tej wiosce nie ma kupca!\n" KOLOR_RESET);
    }
    printf("---------------------------------\n\n");
}

void rysuj_mape(Mapa* mapa, int graczX, int graczY, TypLokacji typ_lokacji) {
    printf("   +");
    for (int x = 0; x < mapa->szerokosc; x++) printf("--");
    printf("+  [%s]\n", nazwy_lokacji[typ_lokacji]);
    printf("   ");
    for (int x = 0; x < mapa->szerokosc; x++) {
        printf("%2d", x);
    }
    printf("\n");
    printf("   +");
    for (int x = 0; x < mapa->szerokosc; x++) printf("--");
    printf("+\n");

    for (int y = 0; y < mapa->wysokosc; y++) {
        printf("%2d |", y);
        for (int x = 0; x < mapa->szerokosc; x++) {
            if (x == graczX && y == graczY) {
                printf(KOLOR_GREEN " @" KOLOR_RESET);
            } else if (typ_lokacji == LOKACJA_WIOSKA && mapa->czy_jest_kupiec && x == 0 && y == 0) {
                // Kupiec zawsze w lewym górnym rogu wioski
                printf(KOLOR_BOLD KOLOR_YELLOW " K" KOLOR_RESET);
            } else {
                switch (mapa->komorki[y][x].typ) {
                    case PUSTE:      printf("\033[1;32m  \033[0m"); break;
                    case SCIANA:     printf(KOLOR_WHITE " #" KOLOR_RESET); break;
                    case SKARB:      printf(KOLOR_YELLOW " S" KOLOR_RESET); break;
                    case SKARB_SPEC: printf(KOLOR_YELLOW " $" KOLOR_RESET); break;
                    case PULAPKA:    printf(KOLOR_RED " T" KOLOR_RESET); break;
                    case PRZECIWNIK: printf(KOLOR_RED " P" KOLOR_RESET); break;
                    case BRAMA:      printf(KOLOR_CYAN " B" KOLOR_RESET); break;
                    default:         printf("  ");
                }
            }
        }
        printf(" |\n");
    }
    printf("   +");
    for (int x = 0; x < mapa->szerokosc; x++) printf("--");
    printf("+\n");
}

/* --- BFS --- */
int is_map_traversable(Mapa* mapa, int startX, int startY) {
    int visited[MAX_WYSOKOSC][MAX_SZEROKOSC] = {{0}};
    Pozycja queue[MAX_WYSOKOSC * MAX_SZEROKOSC];
    int head = 0, tail = 0;
    queue[tail++] = (Pozycja){startX, startY};
    visited[startY][startX] = 1;
    int directions[4][2] = { {0,1}, {1,0}, {0,-1}, {-1,0} };
    while (head < tail) {
        Pozycja current = queue[head++];
        if (mapa->komorki[current.y][current.x].typ == BRAMA)
            return 1;
        for (int i = 0; i < 4; i++) {
            int nx = current.x + directions[i][0];
            int ny = current.y + directions[i][1];
            if (nx >= 0 && nx < mapa->szerokosc && ny >= 0 && ny < mapa->wysokosc) {
                if (!visited[ny][nx] && mapa->komorki[ny][nx].typ != SCIANA) {
                    visited[ny][nx] = 1;
                    queue[tail++] = (Pozycja){nx, ny};
                }
            }
        }
    }
    return 0;
}

int is_skarb_dostepny(Mapa* mapa, int startX, int startY) {
    int visited[MAX_WYSOKOSC][MAX_SZEROKOSC] = {{0}};
    Pozycja queue[MAX_WYSOKOSC * MAX_SZEROKOSC];
    int head = 0, tail = 0;
    queue[tail++] = (Pozycja){startX, startY};
    visited[startY][startX] = 1;
    int directions[4][2] = { {0,1}, {1,0}, {0,-1}, {-1,0} };
    while (head < tail) {
        Pozycja current = queue[head++];
        if (mapa->komorki[current.y][current.x].typ == SKARB ||
            mapa->komorki[current.y][current.x].typ == SKARB_SPEC)
            return 1;
        for (int i = 0; i < 4; i++) {
            int nx = current.x + directions[i][0];
            int ny = current.y + directions[i][1];
            if (nx >= 0 && nx < mapa->szerokosc && ny >= 0 && ny < mapa->wysokosc) {
                if (!visited[ny][nx] && mapa->komorki[ny][nx].typ != SCIANA) {
                    visited[ny][nx] = 1;
                    queue[tail++] = (Pozycja){nx, ny};
                }
            }
        }
    }
    return 0;
}

void generuj_przechodna_mape(Mapa* mapa, TypLokacji* typ_lokacji) {
    *typ_lokacji = rand() % 6;
    do {
        generuj_mape(mapa, *typ_lokacji);
        mapa->komorki[1][1].typ = PUSTE;
    } while (!is_map_traversable(mapa, 1, 1) || !is_skarb_dostepny(mapa, 1, 1));
}

/* --- KUPIEC --- */
void sklep(Postac *gracz, Plecak *plecak) {
    while (1) {
        printf(KOLOR_BOLD KOLOR_MAGENTA "\n=== KUPIEC ===\n" KOLOR_RESET);
        printf("Twoja waluta: %d\n", gracz->waluta);
        printf("1. Sprzedaj przedmiot z plecaka\n");
        printf("2. Kup LEGENDARNY przedmiot\n");
        printf("q. Wyjdz\n");
        char linia[16];
        fgets(linia, sizeof(linia), stdin);
        if (linia[0] == 'q' || linia[0] == 'Q') break;
        int wybor = atoi(linia);
        if (wybor == 1) {
            if (plecak->count == 0) {
                printf("Nie masz nic do sprzedania.\n");
                continue;
            }
            for (int i = 0; i < plecak->count; i++) {
                printf("%d: %s (cena: %d)\n", i, plecak->items[i].nazwa, plecak->items[i].cena);
            }
            printf("Wybierz nr przedmiotu do sprzedania (q aby anulowac): ");
            fgets(linia, sizeof(linia), stdin);
            if (linia[0] == 'q' || linia[0] == 'Q') continue;
            int idx = atoi(linia);
            if (idx >= 0 && idx < plecak->count) {
                printf("Sprzedano %s za %d waluty!\n", plecak->items[idx].nazwa, plecak->items[idx].cena);
                gracz->waluta += plecak->items[idx].cena;
                usun_z_plecaka(plecak, idx);
            }
        } else if (wybor == 2) {
            printf("Dostepne LEGENDARNE przedmioty:\n");
            Przedmiot legendarne[3];
            for (int i = 0; i < 3; i++) {
                legendarne[i] = generuj_przedmiot(gracz);
                legendarne[i].rzadkosc = RZAD_LEG;
                if (i == 0) { legendarne[i].typ = PRZEDMIOT_BRON; snprintf(legendarne[i].nazwa, 50, "EXCALIBUR"); }
                if (i == 1) { legendarne[i].typ = PRZEDMIOT_TARCZA; snprintf(legendarne[i].nazwa, 50, "AEGIS"); }
                if (i == 2) { legendarne[i].typ = PRZEDMIOT_ZBROJA; snprintf(legendarne[i].nazwa, 50, "DRAGON ARMOR"); }
            }
            for (int i = 0; i < 3; i++) {
                printf(KOLOR_BOLD KOLOR_YELLOW "%d: %s (cena: %d, waga: %d)\n" KOLOR_RESET, i, legendarne[i].nazwa, legendarne[i].cena, legendarne[i].waga);
            }
            printf("Wybierz nr przedmiotu do kupienia (q aby anulowac): ");
            fgets(linia, sizeof(linia), stdin);
            if (linia[0] == 'q' || linia[0] == 'Q') continue;
            int idx = atoi(linia);
            if (idx >= 0 && idx < 3) {
                if (gracz->waluta >= legendarne[idx].cena) {
                    if (dodaj_do_plecaka(plecak, legendarne[idx], gracz)) {
                        gracz->waluta -= legendarne[idx].cena;
                        printf(KOLOR_BOLD KOLOR_YELLOW "Kupiono %s!\n" KOLOR_RESET, legendarne[idx].nazwa);
                    }
                } else {
                    printf("Nie masz wystarczajaco waluty!\n");
                }
            }
        }
    }
}

/* --- PORUSZANIE --- */
void porusz_gracza(Mapa* mapa, int* graczX, int* graczY, TypLokacji typ_lokacji, Postac *gracz, Plecak *plecak) {
    char ruch;
    printf("Podaj ruch (W - gora, S - dol, A - lewo, D - prawo, E - ekwipunek");
    if (typ_lokacji == LOKACJA_WIOSKA && mapa->czy_jest_kupiec) printf(", K - kupiec");
    printf("): ");
    scanf(" %c", &ruch);


    if (ruch == 'E' || ruch == 'e') {
        *graczX = -1;
        return;
    }
    if ((ruch == 'K' || ruch == 'k') && typ_lokacji == LOKACJA_WIOSKA && mapa->czy_jest_kupiec) {
        sklep(gracz, plecak);
        *graczX = -2;
        return;
    }

    int nowyX = *graczX, nowyY = *graczY;
    if (ruch == 'W' || ruch == 'w') nowyY--;
    else if (ruch == 'S' || ruch == 's') nowyY++;
    else if (ruch == 'A' || ruch == 'a') nowyX--;
    else if (ruch == 'D' || ruch == 'd') nowyX++;

    if (nowyX >= 0 && nowyX < mapa->szerokosc && nowyY >= 0 && nowyY < mapa->wysokosc) {
        if (mapa->komorki[nowyY][nowyX].typ != SCIANA) {
            *graczX = nowyX;
            *graczY = nowyY;
        }
    }
    printf("\n\n");
}

/* --- WALKA --- */
int oblicz_obrazenia(Postac* attacker, Postac* defender) {
    int bronDamage = 0;
    if (attacker->sloty[SLOT_BRON])
        bronDamage = attacker->sloty[SLOT_BRON]->bonus_obrazen;
    float sila_calkowita = attacker->sila + attacker->bonus_sila;
    float odp_calkowita = defender->odp_pancerza + defender->bonus_odpornosc;

    int damage = (int)(sila_calkowita + bronDamage - odp_calkowita);
    if (damage < 1)
        damage = 1;
    return damage;
}

// --- Zastąp całą funkcję walka poniższą wersją, aby szybkość wpływała na kolejność i dodatkowy atak ---

void walka(Postac* gracz, Postac* przeciwnik, Plecak *plecak) {
    printf(KOLOR_BOLD KOLOR_RED "Napotykasz przeciwnika! Walka rozpoczeta!\n" KOLOR_RESET);

    float szybkosc_gracza = gracz->szybkosc + gracz->bonus_szybkosc;
    float szybkosc_przeciwnika = przeciwnik->szybkosc + przeciwnik->bonus_szybkosc;

    int tura_gracza = 0;
    int tura_przeciwnika = 0;

    // Kto zaczyna? (większa szybkość)
    if (szybkosc_gracza > szybkosc_przeciwnika) {
        tura_gracza = 1;
        printf(KOLOR_CYAN "Gracz atakuje pierwszy (szybkosc: %.2f vs %.2f)\n" KOLOR_RESET, szybkosc_gracza, szybkosc_przeciwnika);
    } else if (szybkosc_gracza < szybkosc_przeciwnika) {
        tura_przeciwnika = 1;
        printf(KOLOR_CYAN "Przeciwnik atakuje pierwszy (szybkosc: %.2f vs %.2f)\n" KOLOR_RESET, szybkosc_gracza, szybkosc_przeciwnika);
    } else {
        // Remis - losowo
        if (rand() % 2 == 0) {
            tura_gracza = 1;
            printf(KOLOR_CYAN "Remis szybkości, gracz zaczyna.\n" KOLOR_RESET);
        } else {
            tura_przeciwnika = 1;
            printf(KOLOR_CYAN "Remis szybkości, przeciwnik zaczyna.\n" KOLOR_RESET);
        }
    }

    while (gracz->HP + gracz->bonus_HP > 0 && przeciwnik->HP > 0) {
        // Gracz atakuje
        if (tura_gracza) {
            int ataki = 1;
            if (szybkosc_gracza > 100.0f) {
                int extra = (int)(szybkosc_gracza - 100.0f);
                if (extra > 0) {
                    int szansa = rand() % 100;
                    if (szansa < extra) ataki++;
                }
            }
            for (int i = 0; i < ataki && przeciwnik->HP > 0; i++) {
                int damage = oblicz_obrazenia(gracz, przeciwnik);
                przeciwnik->HP -= damage;
                printf("Gracz atakuje%s i zadaje %d obrazen. HP przeciwnika: %d\n", ataki > 1 && i > 0 ? " (dodatkowy atak!)" : "", damage, przeciwnik->HP);
            }
            if (przeciwnik->HP <= 0) {
                printf(KOLOR_GREEN "Przeciwnik zostal pokonany!\n" KOLOR_RESET);
                gracz->XP += 30;
                gracz->liczba_wrogow++; // Dodaj to!
                if (rand() % 100 < 40) {
                    Przedmiot item = generuj_przedmiot(&gracz);
                    printf(KOLOR_BOLD KOLOR_YELLOW "Zdobywasz przedmiot: %s\n" KOLOR_RESET, item.nazwa);
                    dodaj_do_plecaka(plecak, item, gracz);
                }
                break;
            }
        }
        // Przeciwnik atakuje
        if (tura_przeciwnika) {
            int ataki = 1;
            if (szybkosc_przeciwnika > 100.0f) {
                int extra = (int)(szybkosc_przeciwnika - 100.0f);
                if (extra > 0) {
                    int szansa = rand() % 100;
                    if (szansa < extra) ataki++;
                }
            }
            for (int i = 0; i < ataki && gracz->HP + gracz->bonus_HP > 0; i++) {
                int damage = oblicz_obrazenia(przeciwnik, gracz);
                gracz->HP -= damage;
                printf("Przeciwnik atakuje%s i zadaje %d obrazen. HP gracza: %d\n", ataki > 1 && i > 0 ? " (dodatkowy atak!)" : "", damage, gracz->HP);
            }
            if ((gracz->HP + gracz->bonus_HP) <= 0) {
                printf(KOLOR_BOLD KOLOR_RED "Gracz zostal pokonany! Koniec gry.\n" KOLOR_RESET);
                pokaz_podsumowanie(gracz);
                free(plecak->items);
                exit(0);
            }
        }
        // Zmiana tury
        tura_gracza = !tura_gracza;
        tura_przeciwnika = !tura_przeciwnika;
    }
    printf("Walka zakonczona zwyciestwem gracza!\n\n");
    printf("Wcisnij ENTER aby kontynuowac...");
    getchar(); getchar();
}

/* --- LEVEL UP --- */
void level_up(Postac* gracz) {
    printf(KOLOR_BOLD KOLOR_GREEN "\nLEVEL UP! Osiagnales poziom %d!\n" KOLOR_RESET, gracz->poziom);
    printf("Wybierz bonus:\n");
    printf("1. +10%% do HP\n");
    printf("2. +10%% do obrazen (sila)\n");
    printf("3. +10%% do odpornosci\n");
    printf("4. +10%% do szybkosc\n");
    int wybor = 0;
    while (wybor < 1 || wybor > 4) {
        printf("Twoj wybor: ");
        scanf("%d", &wybor);
        int c; while ((c = getchar()) != '\n' && c != EOF) {}
    }
    if (wybor == 1) {
        gracz->HP = (int)(gracz->HP * 1.1);
        gracz->max_HP = (int)(gracz->max_HP * 1.1);
        printf("Twoje bazowe HP wzroslo!\n");
    } else if (wybor == 2) {
        gracz->sila *= 1.1f;
        printf("Twoja sila wzrosla!\n");
    } else if (wybor == 3) {
        gracz->odp_pancerza *= 1.1f;
        printf("Twoja odpornosc wzrosla!\n");
    } else if (wybor == 4) {
        gracz->szybkosc *= 1.1f;
        printf("Twoja szybkosc wzrosla!\n");
    }
    gracz->xp_do_lvlu += LEVELUP_XP;
}

/* --- GENEROWANIE POSTACI --- */
Postac generuj_postac() {
    Postac p;
    p.HP = 100 + rand() % 50;
    p.max_HP = p.HP; // <-- USTAW MAKSYMALNE HP NA START
    p.AG = 10 + rand() % 5;
    p.odp_pancerza = 10 + rand() % 10;
    p.sila = 14 + rand() % 20;
    p.mnoznik_hp = 1 + rand() % 5;
    p.waga = 100 + rand() % 20;
    p.zasieg_walki = 10 + rand() % 5;
    p.zasieg_wizji = 50 + rand() % 10;
    p.XP = rand() % 10;
    p.szybkosc = 5 + rand() % 10;
    p.pozycjaX = 1;
    p.pozycjaY = 1;
    for (int i = 0; i < SLOT_ILOSC; i++) p.sloty[i] = NULL;
    p.bonus_HP = 0;
    p.bonus_sila = 0;
    p.bonus_odpornosc = 0;
    p.bonus_szybkosc = 0.0f;
    p.waluta = 30;
    p.poziom = 1;
    p.xp_do_lvlu = LEVELUP_XP;
    p.szczescie = 1 + rand() % 5;
    p.liczba_leczen = 0; //liczba uzytych leczen
    p.liczba_pulapek = 0; //liczba pulapek wpadniętych
    p.liczba_wrogow = 0; //liczba pokonanych wrogów
    return p;
}

Postac generuj_przeciwnika(Postac *gracz) {
    Postac enemy = generuj_postac();
    int poziom = gracz->poziom;

    // Losuj czy przeciwnik jest silny czy słaby (np. 30% szans na słabego)
    int slaby = (rand() % 100 < 30);

    if (slaby) {
        enemy.HP = 30 + rand() % 20;
        enemy.sila = 6 + rand() % 5;
        enemy.odp_pancerza = 2 + rand() % 3;
    } else {
        // Skalowanie z poziomem gracza
        enemy.HP = 40 + poziom * 10 + rand() % (10 + poziom * 2);
        enemy.sila = 8 + poziom * 2 + rand() % (4 + poziom);
        enemy.odp_pancerza = 4 + poziom + rand() % (2 + poziom / 2);
    }
    enemy.AG = 5 + rand() % 5;
    enemy.mnoznik_hp = 1;
    enemy.waga = 50 + rand() % 10;
    enemy.zasieg_walki = 5 + rand() % 3;
    enemy.zasieg_wizji = 20 + rand() % 10;
    enemy.XP = 0;
    enemy.szybkosc = 3 + rand() % 4;
    enemy.pozycjaX = 0;
    enemy.pozycjaY = 0;
    for (int i = 0; i < SLOT_ILOSC; i++) enemy.sloty[i] = NULL;
    Przedmiot *bron = malloc(sizeof(Przedmiot));
    *bron = generuj_przedmiot(gracz);
    enemy.sloty[SLOT_BRON] = bron;
    return enemy;
}

/* --- INFO --- */
void wyswietl_informacje(Postac* gracz) {
    printf(KOLOR_BOLD KOLOR_CYAN "=== STATYSTYKI GRACZA ===\n" KOLOR_RESET);
    int calkowite_HP = gracz->HP + gracz->bonus_HP;
    int max_calkowite_HP = gracz->max_HP + gracz->bonus_HP;
    float calkowita_szybkosc = gracz->szybkosc + gracz->bonus_szybkosc;
    float calkowita_sila = gracz->sila + gracz->bonus_sila;
    printf("Poziom: %d\n", gracz->poziom);
    printf("XP: %ld / %d\n", gracz->XP, gracz->xp_do_lvlu);
    printf("Waluta: %d\n", gracz->waluta);
    printf("Szczescie: %d\n", gracz->szczescie); // DODANE
    printf("HP: %d (bazowe) + %d (bonus) = %d / %d (max)\n", gracz->HP, gracz->bonus_HP, calkowite_HP, max_calkowite_HP);
    for (int i = 0; i < SLOT_ILOSC; i++) {
        if (gracz->sloty[i]) {
            printf("%s: ", i == SLOT_BRON ? "Bron" : i == SLOT_TARCZA ? "Tarcza" : "Zbroja");
            if (gracz->sloty[i]->rzadkosc == RZAD_LEG)
                printf(KOLOR_BOLD KOLOR_YELLOW "%s" KOLOR_RESET "\n", gracz->sloty[i]->nazwa);
            else
                printf("%s\n", gracz->sloty[i]->nazwa);
        }
    }
    printf("Sila: %.2f (bazowa: %.2f + bonus: %d)\n", calkowita_sila, gracz->sila, gracz->bonus_sila);
    printf("Odpornosc: %.2f (bazowa: %.2f + bonus: %d)\n", gracz->odp_pancerza + gracz->bonus_odpornosc, gracz->odp_pancerza, gracz->bonus_odpornosc);
    printf("Szybkosc: %.2f (bazowa: %.2f + bonus: %.2f)\n", calkowita_szybkosc, gracz->szybkosc, gracz->bonus_szybkosc);
    printf("---------------------------------\n\n");
}

void pokaz_podsumowanie(Postac* gracz) {
    printf(KOLOR_BOLD KOLOR_RED "\n=== KONIEC GRY ===\n" KOLOR_RESET);
    printf("Poziom: %d\n", gracz->poziom);
    printf("XP: %ld\n", gracz->XP);
    printf("Pokonanych wrogow: %d\n", gracz->liczba_wrogow);
    printf("Wpadnietych pulapek: %d\n", gracz->liczba_pulapek);
    printf("Szczescie: %d\n", gracz->szczescie);
    printf("Waluta: %d\n", gracz->waluta);
    printf("Dziekujemy za gre!\n");
}

/* --- MAIN --- */
int main() {
    #ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);    // Ustawia UTF-8 w Windowsowej konsoli
    #endif
    Mapa mapa;
    TypLokacji typ_lokacji;
    srand((unsigned int)time(NULL));

    Postac gracz = generuj_postac();
    Plecak plecak;
    init_plecak(&plecak, 40);

    generuj_przechodna_mape(&mapa, &typ_lokacji);

    while (1) {
        czysc_ekran();
        rysuj_legenda(&mapa, typ_lokacji);
        wyswietl_informacje(&gracz);
        rysuj_mape(&mapa, gracz.pozycjaX, gracz.pozycjaY, typ_lokacji);

        int oldX = gracz.pozycjaX;
        int oldY = gracz.pozycjaY;

        porusz_gracza(&mapa, &gracz.pozycjaX, &gracz.pozycjaY, typ_lokacji, &gracz, &plecak);

        if (gracz.pozycjaX == -1) {
            gracz.pozycjaX = oldX;
            gracz.pozycjaY = oldY;
            przegladaj_plecak(&plecak, &gracz);
            continue;
        }
        if (gracz.pozycjaX == -2) {
            gracz.pozycjaX = oldX;
            gracz.pozycjaY = oldY;
            continue;
        }

        TypKomorki aktualna = mapa.komorki[gracz.pozycjaY][gracz.pozycjaX].typ;
        if (typ_lokacji == LOKACJA_WIOSKA && mapa.czy_jest_kupiec && gracz.pozycjaX == 0 && gracz.pozycjaY == 0) {
            sklep(&gracz, &plecak);
            // Po wyjściu ze sklepu gracz wraca na poprzednie pole, żeby nie blokować wejścia do sklepu
            gracz.pozycjaX = oldX;
            gracz.pozycjaY = oldY;
            continue;
        }
        if (aktualna == PRZECIWNIK) {
            Postac przeciwnik = generuj_przeciwnika(&gracz);
            walka(&gracz, &przeciwnik, &plecak);
            for (int i = 0; i < SLOT_ILOSC; i++)
                if (przeciwnik.sloty[i]) free(przeciwnik.sloty[i]);
            mapa.komorki[gracz.pozycjaY][gracz.pozycjaX].typ = PUSTE;
            if (gracz_ma_legendarny_amulet(&plecak)) {
                int max_hp = gracz.max_HP + gracz.bonus_HP;
                int przed = gracz.HP;
                gracz.HP += 10;
                if (gracz.HP > max_hp) gracz.HP = max_hp;
                printf(KOLOR_GREEN "Amulet Regeneracji leczy cie o 10 HP po walce! (HP: %d -> %d)\n" KOLOR_RESET, przed, gracz.HP);
                printf("Wcisnij ENTER aby kontynuowac...");
                getchar(); getchar();
            }
        } else if (aktualna == SKARB) {
            printf(KOLOR_BOLD KOLOR_MAGENTA "Znalazles skarb! Zdobywasz 50 XP.\n" KOLOR_RESET);
            gracz.XP += 50;
            Przedmiot item = generuj_przedmiot(&gracz);
            if (!dodaj_do_plecaka(&plecak, item, &gracz)) {
                printf(KOLOR_RED "Brak miejsca w plecaku!\n" KOLOR_RESET);
                printf("Czy chcesz wyrzucic cos z plecaka, aby podniesc '%s'? (T/N): ", item.nazwa);
                char odp[8];
                fgets(odp, sizeof(odp), stdin);
                if (odp[0] == 'T' || odp[0] == 't') {
                    przegladaj_plecak(&plecak, &gracz);
                    if (dodaj_do_plecaka(&plecak, item, &gracz)) {
                        printf(KOLOR_BOLD KOLOR_YELLOW "Otrzymujesz przedmiot: %s\n" KOLOR_RESET, item.nazwa);
                    } else {
                        printf(KOLOR_RED "Nadal brak miejsca. Przedmiot przepada.\n" KOLOR_RESET);
                    }
                } else {
                    printf("Przedmiot przepada.\n");
                }
            } else {
                printf(KOLOR_BOLD KOLOR_YELLOW "Otrzymujesz przedmiot: %s\n" KOLOR_RESET, item.nazwa);
            }
            mapa.komorki[gracz.pozycjaY][gracz.pozycjaX].typ = PUSTE;
            printf("Wcisnij ENTER aby kontynuowac...");
            getchar(); getchar();
        } else if (aktualna == SKARB_SPEC) {
            printf(KOLOR_BOLD KOLOR_MAGENTA "Znalazles specjalny skarb ($)!\n" KOLOR_RESET);
            if (rand() % 100 < 50) {
                printf(KOLOR_RED "Niestety, skarb byl pusty!\n" KOLOR_RESET);
            } else {
                printf(KOLOR_BOLD KOLOR_YELLOW "Masz szczescie! Otrzymujesz lepszy przedmiot!\n" KOLOR_RESET);
                Przedmiot item = generuj_przedmiot(&gracz);
                item.rzadkosc = RZAD_LEG;
                snprintf(item.nazwa, 50, "LEPSZY %s", item.nazwa);
                item.cena *= 2;
                if (dodaj_do_plecaka(&plecak, item, &gracz)) {
                    printf(KOLOR_BOLD KOLOR_YELLOW "Otrzymujesz przedmiot: %s\n" KOLOR_RESET, item.nazwa);
                } else {
                    printf(KOLOR_RED "Nie udało się dodać przedmiotu do plecaka!\n" KOLOR_RESET);
                }
            }
            mapa.komorki[gracz.pozycjaY][gracz.pozycjaX].typ = PUSTE;
            printf("Wcisnij ENTER aby kontynuowac...");
            getchar(); getchar();
        } else if (aktualna == PULAPKA) {
            int dmg = 3 + gracz.poziom - (gracz.szczescie / 3); // np. 3 + poziom - szczęście/3
            if (dmg < 2) dmg = 2;
            printf(KOLOR_RED "Wpadles w pulapke! Tracisz %d HP i zyskujesz 1 szczescia.\n" KOLOR_RESET, dmg);
            gracz.HP -= dmg;
            gracz.szczescie += 1;
            gracz.liczba_pulapek++;
            if (gracz_ma_legendarny_amulet(&plecak)) {
                int max_hp = gracz.max_HP + gracz.bonus_HP;
                int przed = gracz.HP;
                gracz.HP += 5;
                if (gracz.HP > max_hp) gracz.HP = max_hp;
                printf(KOLOR_GREEN "Amulet Regeneracji leczy cie o 5 HP po pulapce! (HP: %d -> %d)\n" KOLOR_RESET, przed, gracz.HP);
            }
            if ((gracz.HP + gracz.bonus_HP) <= 0) {
                printf(KOLOR_BOLD KOLOR_RED "Umierasz z powodu pulapki! Koniec gry.\n" KOLOR_RESET);
                pokaz_podsumowanie(&gracz);
                free(plecak.items);
                for (int i = 0; i < SLOT_ILOSC; i++) if (gracz.sloty[i]) free(gracz.sloty[i]);
                exit(0);
            }
            mapa.komorki[gracz.pozycjaY][gracz.pozycjaX].typ = PUSTE;
            printf("Wcisnij ENTER aby kontynuowac...");
            getchar(); getchar();
        } else if (aktualna == BRAMA) {
            printf(KOLOR_BOLD KOLOR_MAGENTA "Weszles przez brame! Przechodzisz na kolejny poziom.\n" KOLOR_RESET);
            generuj_przechodna_mape(&mapa, &typ_lokacji);
            gracz.pozycjaX = 1;
            gracz.pozycjaY = 1;
        }

        // LEVEL UP
        while (gracz.XP >= gracz.xp_do_lvlu) {
            gracz.poziom++;
            level_up(&gracz);
        }
    }

    free(plecak.items);
    for (int i = 0; i < SLOT_ILOSC; i++) if (gracz.sloty[i]) free(gracz.sloty[i]);
    return 0;
}

